return(scorecard)
}
# 4. Data Cleaning & Filtering -------------------------------------------------
clean_bond_data <- function(df, country_name, ref_date) {
# Filtrage des instruments (Bonds nominaux uniquement)
if (country_name == "France") {
df_clean <- df %>% filter(Series == "OAT")
} else if (country_name == "Germany") {
df_clean <- df %>% filter(!Series %in% c("G", "TWIN"))
} else if (country_name == "Italy") {
df_clean <- df %>% filter(!Series %in% c("CPI", "ICPI", "PIU", "VALR", "FUT"))
}
# Renommage et Conversion
df_clean <- df_clean %>%
rename(
RawYield = `Mid Yield to Convention`,
MaturityStr = Maturity,
RawAmt = `Amt Out`,
RawCpn = Cpn
) %>%
mutate(
Yield = suppressWarnings(as.numeric(as.character(RawYield))),
Amt_Out = suppressWarnings(as.numeric(as.character(RawAmt))),
Cpn = suppressWarnings(as.numeric(as.character(RawCpn))),
MaturityDate = as.Date(MaturityStr, format = "%d/%m/%Y"),
Country = country_name,
# Calcul de la maturité en années
Maturity = as.numeric(MaturityDate - ref_date) / 365.25
) %>%
# Nettoyage des NA et valeurs aberrantes
filter(!is.na(Yield), !is.na(Maturity), !is.na(Cpn), Maturity > 0) %>%
select(Country, MaturityDate, Maturity, Yield, Amt_Out, Cpn)
return(df_clean)
}
# --- Préparation de la date d'analyse ---
# On convertit temporairement en date pour trouver le min global
dates_vec <- c(
as.Date(data_france$Maturity, format="%d/%m/%Y"),
as.Date(data_allemagne$Maturity, format="%d/%m/%Y"),
as.Date(data_italie$Maturity, format="%d/%m/%Y")
)
analysis_date <- min(dates_vec, na.rm=TRUE) - 2
message("Date d'analyse fixée au : ", analysis_date)
# --- Création du dataset global nettoyé ---
df_all <- bind_rows(
clean_bond_data(data_france, "France", analysis_date),
clean_bond_data(data_allemagne, "Germany", analysis_date),
clean_bond_data(data_italie, "Italy", analysis_date)
)
# 5. Modèle naïf: Regression linéaire ------------------------------------------
# Liste pour stocker les résultats
plots_reglin <- list()
scorecards_reglin <- list()
data_list <- split(df_all, df_all$Country)
for (country in names(data_list)) {
df <- data_list[[country]]
model_lin <- lm(Yield ~ Maturity, data = df)
# L'évaluateur attend une fonction func(maturité) -> rendement
predict_lin <- function(m) {
predict(model_lin, newdata = data.frame(Maturity = m))
}
# Calcul des Métriques
score <- evaluate_model_performance(
model_name = paste("Linear_", country),
data = df,
predict_func = predict_lin,
col_weight = "Amt_Out"
)
scorecards_reglin[[country]] <- score
# Visualisation
grid_x <- seq(0, 50, length.out = 500)
grid_y <- predict_lin(grid_x)
line_data <- data.frame(Maturity = grid_x, Yield = grid_y)
p <- ggplot(df, aes(x = Maturity, y = Yield)) +
# 1. Les points observés (transparents pour voir la densité)
geom_point(color = colors_flags[country], alpha = 0.6, size = 2) +
# 2. Le Modèle (La Droite)
geom_line(data = line_data, aes(x = Maturity, y = Yield),
color = "black", linetype = "dashed", size = 1) +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
# 3. Méta-informations
labs(
title = paste(country, "- Modèle Linéaire"),
subtitle = paste("RMSE Pondéré:", score$W_RMSE, "| Biais 10-30Y:", score$`Bias_10-30Y`),
x = "Maturité (Années)",
y = "Rendement (Yield %)"
) +
theme_minimal() +
theme(plot.title = element_text(face = "bold", color = colors_flags[country]))
# Graphique des résidus pour montrer le fameux "U inversé"
df$Residus <- df$Yield - predict(model_lin, df)
p_res <- ggplot(df, aes(x = Maturity, y = Residus)) +
geom_point(color = colors_flags[country], alpha = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_smooth(method = "loess", se = FALSE, color = "gray", linetype = "dotted") +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
labs(title = "Structure des Résidus", y = "Résidu (bps)", x = "Maturité") +
theme_minimal()
# On combine les deux graphes (Haut : Fit, Bas : Résidus)
plots_reglin[[country]] <- grid.arrange(p, p_res, nrow = 2, heights = c(2, 1))
}
# Affichage du tableau récapitulatif
final_scorecard_reglin <- bind_rows(scorecards_reglin)
print(final_scorecard_reglin)
# 6. Modèle NSS OLS ------------------------------------------------------------
# Définition de la fonction NSS
# b0 : Taux long terme (Level)
# b1 : Taux court - Taux long (Slope)
# b2 : Courbure à moyen terme (Hump 1)
# b3 : Courbure à long terme (Hump 2)
# tau1, tau2 : Facteurs d'échelle temporelle
nss_func <- function(m, params) {
b0 <- params[1]
b1 <- params[2]
b2 <- params[3]
b3 <- params[4]
tau1 <- params[5]
tau2 <- params[6]
term1 <- (1 - exp(-m/tau1)) / (m/tau1)
term2 <- term1 - exp(-m/tau1)
term3 <- (1 - exp(-m/tau2)) / (m/tau2) - exp(-m/tau2)
return(b0 + b1*term1 + b2*term2 + b3*term3)
}
# Fonction d'optimisation (OLS = Minimiser la somme des carrés des erreurs)
fit_nss_ols <- function(df) {
# Fonction Objective : Somme des Carrés des Résidus (SSR)
ssr_cost <- function(params) {
# Contraintes : tau doit être positif
if(params[5] <= 0 || params[6] <= 0) {
return(1e9)
}
preds <- nss_func(df$Maturity, params)
sum((df$Yield - preds)^2) # OLS : Pas de pondération par Amt_Out
}
# Paramètres initiaux (Guessing intelligent pour aider l'algo)
start_params <- c(b0=3, b1=-1, b2=0, b3=0, tau1=2, tau2=10)
# Optimisation via Nelder-Mead (Robuste)
opt <- optim(par = start_params, fn = ssr_cost, control = list(maxit = 5000))
return(opt$par)
}
# Exécution de a méthode
plots_nssols <- list()
scorecards_nssols <- list()
models_nssols_params <- list() # On stocke les paramètres pour plus tard
for (country in names(data_list)) {
df <- data_list[[country]]
best_params <- fit_nss_ols(df)
models_nssols_params[[country]] <- best_params
# Wrapper de prédiction
predict_nss <- function(m){
nss_func(m, best_params)
}
# Calcul des métriques
score <- evaluate_model_performance(
model_name = paste("NSS_OLS_", country),
data = df,
predict_func = predict_nss,
col_weight = "Amt_Out"
)
scorecards_nssols[[country]] <- score
# Visualisation
grid_x <- seq(0, 50, length.out = 500)
line_data <- data.frame(Maturity = grid_x, Yield = predict_nss(grid_x))
# Graphe Principal
p <- ggplot(df, aes(x = Maturity, y = Yield)) +
# Points : La taille dépend du Volume (Amt_Out) pour voir les "Trash Bonds"
geom_point(aes(size = Amt_Out), color = colors_flags[country], alpha = 0.5) +
# La Courbe NSS
geom_line(data = line_data, aes(x = Maturity, y = Yield),
color = "black", size = 1) +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
labs(
title = paste(country, "- NSS Classique (OLS)"),
subtitle = paste("Le modèle traite le point petit (Trash) comme le gros (Benchmark)."),
x = "Maturité", y = "Yield (%)", size = "Volume"
) +
theme_minimal() +
theme(plot.title = element_text(face = "bold", color = colors_flags[country]))
# Graphe des Résidus
df$Residus <- df$Yield - predict_nss(df$Maturity)
p_res <- ggplot(df, aes(x = Maturity, y = Residus)) +
geom_point(aes(size = Amt_Out), color = colors_flags[country], alpha = 0.5) +
geom_hline(yintercept = 0) +
# On ajoute une ligne de tendance locale pour voir si le biais persiste
geom_smooth(method = "loess", se = FALSE, color = "gray", linetype = "dotted") +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
labs(title = "Résidus : Hétéroscédasticité visible", y = "Bps", x = "Maturité", size = "Volume") +
theme_minimal()
plots_nssols[[country]] <- grid.arrange(p, p_res, nrow = 2, heights = c(2, 1))
}
# Affichage des Résultats
final_scorecard_nssols <- bind_rows(scorecards_nssols)
print(final_scorecard_nssols)
# Comparaison RegLin vs NSS_OLS
print("Comparaison rapide RMSE (Linear vs NSS OLS):")
print(bind_rows(final_scorecard_reglin %>% select(Model, W_RMSE),
final_scorecard_nssols %>% select(Model, W_RMSE)))
# 7. Modèle NSS WLS ------------------------------------------------------------
# Hypothèse : On donne plus de poids aux obligations liquides (Gros Amt_Out).
# Cela permet d'ignorer les "Trash Bonds" qui faussent la courbe.
fit_nss_wls <- function(df, x_col = "Maturity") {
weights <- df$Amt_Out
weights[is.na(weights)] <- 0
if(sum(weights) == 0) weights <- rep(1, length(weights))
weights <- weights / sum(weights)
# Détection de l'échelle pour le "sanity check"
is_duration <- x_col == "Duration"
check_point <- if(is_duration) 20 else 50
# Fonction Coût
ssr_cost_wls <- function(params) {
# Contrainte: tau doit être positif
if(params[5] <= 0.1 || params[6] <= 0.5){
return(1e9)
}
# Calcul des prédictions
preds <- nss_func(df[[x_col]], params)
# Erreur pondérée
weighted_sq_err <- sum(weights * (df$Yield - preds)^2)
# Pénalité de stabilité (Tail Check)
# Si la courbe explose à 20 ans (Duration) ou 50 ans (Maturité), on pénalise
tail_rate <- nss_func(check_point, params)
penalty <- 0
if(tail_rate < -2 || tail_rate > 15){
penalty <- 1000
}
return(weighted_sq_err + penalty)
}
# Paramètres initiaux
mean_yield <- mean(df$Yield, na.rm=TRUE)
start_params <- c(b0=mean_yield, b1=0, b2=0, b3=0, tau1=1, tau2=5)
# Optimisation
opt <- optim(par = start_params,
fn = ssr_cost_wls,
method = "Nelder-Mead",
control = list(maxit = 10000))
return(opt$par)
}
plots_nsswls <- list()
scorecards_nsswls <- list()
for (country in names(data_list)) {
df <- data_list[[country]]
best_params <- fit_nss_wls(df, x_col = "Maturity")
# Prediction
predict_nss_wls <- function(m){
nss_func(m, best_params)
}
score <- evaluate_model_performance(paste("NSS_WLS_", country), df, predict_nss_wls, "Amt_Out")
scorecards_nsswls[[country]] <- score
# Visualisation
grid_x <- seq(0, 50, length.out = 500)
line_data <- data.frame(Maturity = grid_x, Yield = predict_nss_wls(grid_x))
p <- ggplot(df, aes(x = Maturity, y = Yield)) +
geom_point(aes(size = Amt_Out), color = colors_flags[country], alpha = 0.5) +
geom_line(data = line_data, color = "black", size = 1) +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
labs(title = paste(country, "- NSS Pondéré par le Volume (WLS)"),
subtitle = "Fit Pondéré (Algorithme Nelder-Mead)", y="Yield") +
theme_minimal() + theme(plot.title = element_text(face="bold", color=colors_flags[country]))
df$Residus <- df$Yield - predict_nss_wls(df$Maturity)
p_res <- ggplot(df, aes(x = Maturity, y = Residus)) +
geom_point(aes(size = Amt_Out), color = colors_flags[country], alpha = 0.5) +
geom_hline(yintercept = 0) +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
labs(title = "Résidus", y="Bps", size="Volume") + theme_minimal()
plots_nsswls[[country]] <- grid.arrange(p, p_res, nrow=2, heights=c(2,1))
}
# Affichage des Résultats
final_scorecard_nsswls <- bind_rows(scorecards_nsswls)
print(final_scorecard_nsswls)
# 8. Modèle NSS WLS en Duration ------------------------------------------------
# Fonction Macaulay (formule fermée)
calculate_duration <- function(yield_pct, coupon_pct, maturity) {
y <- yield_pct / 100; c <- coupon_pct / 100; n <- maturity
res <- numeric(length(n))
for(i in seq_along(n)) {
if(c[i] == 0) { res[i] <- n[i] } else {
res[i] <- (1+y[i])/y[i] - (1+y[i]+n[i]*(c[i]-y[i])) / (c[i]*((1+y[i])^n[i]-1) + y[i])
}
}
return(res)
}
plots_nsswlsduration <- list()
scorecards_nsswlsduration <- list()
for (country in names(data_list)) {
df <- data_list[[country]]
# 1. Calcul de la Duration
df$Duration <- calculate_duration(df$Yield, df$Cpn, df$Maturity)
# 2. Fitting (WLS sur DURATION)
best_params_dur <- fit_nss_wls(df, x_col = "Duration")
# 3. Prediction
predict_nss_dur <- function(d) { nss_func(d, best_params_dur) }
# Hack pour l'évaluation
df_eval <- df
df_eval$Maturity <- df$Duration
score <- evaluate_model_performance(paste("NSS_Duration_", country), df_eval, predict_nss_dur, "Amt_Out")
scorecards_nsswlsduration[[country]] <- score
# 4. Visu
grid_d <- seq(0, 50, length.out = 500)
line_data <- data.frame(Duration = grid_d, Yield = predict_nss_dur(grid_d))
p <- ggplot(df, aes(x = Duration, y = Yield)) +
geom_point(aes(size = Amt_Out), color = colors_flags[country], alpha = 0.5) +
geom_line(data = line_data, color = "purple", size = 1) +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
labs(title = paste(country, "- NSS sur Duration (Acte 4)"),
subtitle = "L'axe Duration comprime l'échelle temporelle (Nelder-Mead)",
x = "Duration", y = "Yield") +
theme_minimal() + theme(plot.title = element_text(face="bold", color=colors_flags[country]))
df$Residus <- df$Yield - predict_nss_dur(df$Duration)
p_res <- ggplot(df, aes(x = Duration, y = Residus)) +
geom_point(aes(size = Amt_Out), color = colors_flags[country], alpha = 0.5) +
geom_hline(yintercept = 0) +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
labs(title = "Résidus vs Duration", y="Bps", x="Duration", size="Volume") + theme_minimal()
plots_nsswlsduration[[country]] <- grid.arrange(p, p_res, nrow=2, heights=c(2,1))
}
# Affichage des Résultats
final_scorecard_nsswlsduration <- bind_rows(scorecards_nsswlsduration)
print(final_scorecard_nsswlsduration)
###########################
#TEST WIP
##########################
# ==============================================================================
# INTERLUDE : VÉRIFICATION DE L'HYPOTHÈSE (OLS PUR) - CORRIGÉ
# ==============================================================================
library(minpack.lm)
library(dplyr)
library(ggplot2)
library(gridExtra)
# 1. Fonction d'optimisation OLS PURE (Sans Poids)
fit_nss_ols_robust <- function(df, x_col = "Maturity") {
y_obs <- df$Yield
x_obs <- df[[x_col]] # C'est ici que ça plantait si x_col n'existe pas
# Initialisation adaptée à l'échelle
mean_y <- mean(y_obs, na.rm=TRUE)
if (x_col == "Duration") {
start_list <- list(b0 = mean_y+1, b1 = -1, b2 = 0, b3 = 0, tau1 = 1.0, tau2 = 3.0)
} else {
start_list <- list(b0 = mean_y+1, b1 = -1, b2 = 0, b3 = 0, tau1 = 2.0, tau2 = 10.0)
}
# Formule NSS explicite pour nlsLM
nss_formula <- y_obs ~ b0 +
b1 * ((1 - exp(-x_obs/tau1)) / (x_obs/tau1)) +
b2 * (((1 - exp(-x_obs/tau1)) / (x_obs/tau1)) - exp(-x_obs/tau1)) +
b3 * (((1 - exp(-x_obs/tau2)) / (x_obs/tau2)) - exp(-x_obs/tau2))
# Optimisation
tryCatch({
fit <- nlsLM(nss_formula, start = start_list,
lower = c(b0=0, b1=-30, b2=-100, b3=-100, tau1=0.1, tau2=0.2),
upper = c(b0=20, b1=30, b2=100, b3=100, tau1=20, tau2=50),
control = nls.lm.control(maxiter = 1000, ftol=1e-8))
return(coef(fit))
}, error = function(e) { return(NULL) })
}
# 2. Boucle de Comparaison
results_comparison <- list()
plots_comparison <- list()
print("--- Comparaison OLS : Maturité vs Duration ---")
for (country in names(data_list)) {
df <- data_list[[country]]
# --- CORRECTION ICI : On recalcule la Duration pour être sûr qu'elle existe ---
# On utilise ta fonction calculate_duration (qui est maintenant la Modified Duration)
df$Duration <- calculate_duration(df$Yield, df$Cpn, df$Maturity)
# A. Modèle Maturité
params_mat <- fit_nss_ols_robust(df, "Maturity")
if(is.null(params_mat)) next # Sécurité si le fit échoue
preds_mat <- nss_func(df$Maturity, params_mat)
rmse_mat <- sqrt(mean((df$Yield - preds_mat)^2))
# B. Modèle Duration
params_dur <- fit_nss_ols_robust(df, "Duration")
if(is.null(params_dur)) next
preds_dur <- nss_func(df$Duration, params_dur)
rmse_dur <- sqrt(mean((df$Yield - preds_dur)^2))
# Stockage Résultats
results_comparison[[country]] <- tibble(
Country = country,
RMSE_Maturity_OLS = round(rmse_mat, 5),
RMSE_Duration_OLS = round(rmse_dur, 5),
Gain_Pct = round((rmse_mat - rmse_dur)/rmse_mat * 100, 2)
)
# C. Visualisation des Résidus
df$Resid_Mat <- df$Yield - preds_mat
df$Resid_Dur <- df$Yield - preds_dur
p1 <- ggplot(df, aes(x = Maturity, y = Resid_Mat)) +
geom_point(alpha=0.5, color="blue") + geom_hline(yintercept=0) +
labs(title=paste(country, "Maturity OLS"), subtitle=paste("RMSE:", round(rmse_mat,4)), y="Residus") + theme_minimal()
p2 <- ggplot(df, aes(x = Duration, y = Resid_Dur)) +
geom_point(alpha=0.5, color="purple") + geom_hline(yintercept=0) +
labs(title=paste(country, "Duration OLS"), subtitle=paste("RMSE:", round(rmse_dur,4)), y="Residus") + theme_minimal()
plots_comparison[[country]] <- grid.arrange(p1, p2, nrow=1)
}
final_comparison <- bind_rows(results_comparison)
print(final_comparison)
# 8. Modèle NSS WLS avec pondération par la Duration ---------------------------
calculate_duration <- function(yield_pct, coupon_pct, maturity_years) {
y <- yield_pct / 100
c <- coupon_pct / 100
n_bonds <- length(maturity_years)
duration <- numeric(n_bonds)
for (i in seq_len(n_bonds)) {
# Nombre de paiements (arrondi standard)
n <- ceiling(maturity_years[i])
# Cas zéro-coupon
if (c[i] == 0) {
duration[i] <- maturity_years[i]
next
}
# Flux de trésorerie
times <- 1:n
cashflows <- rep(c[i], n)
cashflows[n] <- cashflows[n] + 1  # remboursement du nominal
# Actualisation
discount_factors <- 1 / (1 + y[i])^times
pv_cashflows <- cashflows * discount_factors
# Prix
price <- sum(pv_cashflows)
# Duration de Macaulay
duration[i] <- sum(times * pv_cashflows) / price
}
return(duration)
}
plots_nsswls_durweight <- list()
scorecards_nsswls_durweight <- list()
for (country in names(data_list)) {
df <- data_list[[country]]
# 1. Calcul de la Duration (Macaulay)
df$Duration <- calculate_duration(df$Yield, df$Cpn, df$Maturity)
# 2. Poids économiques : Duration × Amount Outstanding
df$W_Dur <- df$Duration * df$Amt_Out
df$W_Dur[is.na(df$W_Dur)] <- 0
df$W_Dur <- df$W_Dur / sum(df$W_Dur)  # normalisation
# 3. Fonction coût NSS WLS (pondérée par Duration)
ssr_cost_dur_wls <- function(params) {
if(params[5] <= 0.1 || params[6] <= 0.5) return(1e9)
preds <- nss_func(df$Maturity, params)
sum(df$W_Dur * (df$Yield - preds)^2)
}
# 4. Estimation
start_params <- c(
b0 = mean(df$Yield),
b1 = -1,
b2 = 0,
b3 = 0,
tau1 = 1,
tau2 = 5
)
opt <- optim(
par = start_params,
fn = ssr_cost_dur_wls,
method = "Nelder-Mead",
control = list(maxit = 10000)
)
best_params <- opt$par
# 5. Prédiction
predict_nss <- function(m) nss_func(m, best_params)
# 6. Évaluation (inchangée)
score <- evaluate_model_performance(
model_name = paste("NSS_WLS_DurationWeight_", country),
data = df,
predict_func = predict_nss,
col_weight = "Amt_Out" #"W_Dur"
)
scorecards_nsswls_durweight[[country]] <- score
# 7. Visualisation
grid_x <- seq(0, 50, length.out = 500)
line_data <- data.frame(Maturity = grid_x, Yield = predict_nss(grid_x))
p <- ggplot(df, aes(x = Maturity, y = Yield)) +
geom_point(aes(size = W_Dur), color = colors_flags[country], alpha = 0.5) +
geom_line(data = line_data, color = "black", size = 1) +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
labs(
title = paste(country, "- NSS WLS pondéré par la Duration"),
subtitle = "Les obligations longues dominent la perte (logique DV01)",
x = "Maturité",
y = "Yield",
size = "Poids éco"
) +
theme_minimal() +
theme(plot.title = element_text(face = "bold", color = colors_flags[country]))
df$Residus <- df$Yield - predict_nss(df$Maturity)
p_res <- ggplot(df, aes(x = Maturity, y = Residus)) +
geom_point(aes(size = W_Dur), color = colors_flags[country], alpha = 0.5) +
geom_hline(yintercept = 0) +
scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 5)) +
labs(title = "Résidus pondérés par la Duration", y = "Bps", size = "Poids éco") +
theme_minimal()
plots_nsswls_durweight[[country]] <- grid.arrange(p, p_res, nrow = 2, heights = c(2,1))
}
final_scorecard_nsswls_durweight <- bind_rows(scorecards_nsswls_durweight)
print(final_scorecard_nsswls_durweight)
# 4. Modeling (NSS & Splines) ---------------------------------------------
# Nelson-Siegel-Svensson Function
nss_func <- function(p, t) {
if(any(is.na(p))) return(rep(NA, length(t)))
term1 <- (1 - exp(-t/p[5])) / (t/p[5])
term2 <- term1 - exp(-t/p[5])
term3 <- (1 - exp(-t/p[6])) / (t/p[6]) - exp(-t/p[6])
return(p[1] + p[2]*term1 + p[3]*term2 + p[4]*term3)
}
# Optimization Wrapper
fit_nss <- function(data) {
obj <- function(p) {
if(p[5] <= 0 || p[6] <= 0) return(1e9) # Constraints
sum((data$Yield - nss_func(p, data$TTM))^2)
}
# Start: Beta0, Beta1, Beta2, Beta3, Tau1, Tau2
start <- c(3, -1, -1, 0, 2, 5)
tryCatch(optim(par=start, fn=obj, method="BFGS")$par, error=function(e) rep(NA, 6))
}
# Create Grid covering max maturity
max_ttm <- max(df_all$TTM, na.rm=TRUE)
grid_ttm <- seq(0.1, ceiling(max_ttm) + 1, length.out = 200)
load("C:/Users/theos/Desktop/Projet Stat App/.RData")
